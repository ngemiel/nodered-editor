<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node-RED Web Editor @ngemiel</title>
  <style>
    body { margin:0; font-family:-apple-system,system-ui,Arial,sans-serif; background:#f0f0f0; }
    #toolbar { padding:12px; background:#d32f2f; color:white; text-align:center; box-shadow:0 2px 10px rgba(0,0,0,0.2); display:flex; flex-wrap:wrap; justify-content:center; align-items:center; gap:8px; }
    button { padding:8px 16px; border:none; border-radius:6px; cursor:pointer; font-weight:bold; background:white; color:#d32f2f; font-size:14px; }
    button:hover { background:#ffebee; }
    #exportBtn { background:#4caf50; color:white; }
    #resetBtn { background:#d50000; color:white; }
    .social-btn { background:#0088cc; color:white; } /* Telegram */
    .social-btn.whatsapp { background:#25D366; }
    #canvas { height:80vh; position:relative; background:#fdfdfd; }
    .node { position:absolute; width:100px; height:50px; background:#87CEFA; border:2px solid #000; border-radius:8px; text-align:center; line-height:50px; cursor:move; user-select:none; box-shadow:0 3px 8px rgba(0,0,0,0.15); font-weight:bold; font-size:13px; color:#000; }
    .node.input { background:#A8E6A1; border-color:#2e7d32; }
    .node.function { background:#B3E5FC; border-color:#01579b; }
    .node.output { background:#FFAB91; border-color:#d84315; }
    .node.telegram { background:#7FD7FF; border-color:#0088cc; }
    .node.whatsapp { background:#A8E6CF; border-color:#25D366; }
    .port { width:12px; height:12px; background:#000; border-radius:50%; position:absolute; top:50%; transform:translateY(-50%); cursor:crosshair; }
    .port.in { left:-6px; }
    .port.out { right:-6px; }
    svg.connections { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:1; }
    svg.connections path { fill:none; stroke:#000; stroke-width:3; }
    #contextMenu { position:absolute; background:white; border:2px solid #d32f2f; border-radius:8px; padding:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3); z-index:9999; display:none; font-size:14px; }
    #contextMenu button { background:#d32f2f; color:white; width:100%; margin:4px 0; padding:8px; }
    a { color:white; text-decoration:underline; font-size:14px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <h2 style="margin:0 10px 0 0; font-size:18px;">Node-RED Web Editor @ngemiel</h2>
    <button onclick="addNode('input')">+ Inject</button>
    <button onclick="addNode('function')">+ Function</button>
    <button onclick="addNode('output')">+ Debug</button>
    <button class="social-btn" onclick="addNode('telegram')">Telegram</button>
    <button class="social-btn whatsapp" onclick="addNode('whatsapp')">WhatsApp</button>
    <button onclick="saveFlow()">Simpan</button>
    <button onclick="loadFlow()">Muat</button>
    <button id="exportBtn" onclick="exportFlow()">Export</button>
    <button id="resetBtn" onclick="resetCanvas()">Reset</button>
    <a href="/">‚Üê JSON Editor</a>
  </div>
  <div id="canvas">
    <svg class="connections"></svg>
  </div>
  <div id="contextMenu">
    <button onclick="deleteNode(currentNodeId)">Delete Node</button>
    <button onclick="hideContextMenu()">Cancel</button>
  </div>

  <script>
    let nodes = JSON.parse(localStorage.getItem('nodes')||'[]');
    let edges = JSON.parse(localStorage.getItem('edges')||'[]');
    let dragging = null;
    let connecting = null;
    let currentNodeId = null;
    const canvas = document.getElementById('canvas');
    const svg = document.querySelector('svg.connections');
    const contextMenu = document.getElementById('contextMenu');

    function addNode(type) {
      const labels = {
        input: 'Inject', function: 'Function', output: 'Debug',
        telegram: 'Telegram', whatsapp: 'WhatsApp'
      };
      const classes = {
        telegram: 'telegram', whatsapp: 'whatsapp'
      };
      nodes.push({
        id: 'n'+Date.now(),
        type,
        class: classes[type] || type,
        x: 150 + Math.random()*500,
        y: 100 + Math.random()*300,
        label: labels[type]
      });
      render();
      saveFlow();
    }

    function drawConnections() {
      svg.innerHTML = '';
      edges.forEach(edge => {
        const src = nodes.find(n=>n.id===edge.source);
        const dst = nodes.find(n=>n.id===edge.target);
        if (!src || !dst) return;
        const x1 = src.x + 106;
        const y1 = src.y + 25;
        const x2 = dst.x - 6;
        const y2 = dst.y + 25;
        const curve = Math.abs(x2-x1)*0.5;
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d',`M${x1},${y1} C${x1+curve},${y1} ${x2-curve},${y2} ${x2},${y2}`);
        svg.appendChild(path);
      });
    }

    function renderNodes() {
      document.querySelectorAll('.node').forEach(n=>n.remove());
      nodes.forEach(node => {
        const div = document.createElement('div');
        div.className = `node ${node.class || node.type}`;
        div.id = node.id;
        div.innerText = node.label;
        div.style.left = node.x + 'px';
        div.style.top = node.y + 'px';

        const portIn = document.createElement('div');
        portIn.className = 'port in';
        const portOut = document.createElement('div');
        portOut.className = 'port out';
        div.appendChild(portIn);
        div.appendChild(portOut);

        div.addEventListener('contextmenu', e=>{
          e.preventDefault();
          currentNodeId = node.id;
          contextMenu.style.left = e.clientX+'px';
          contextMenu.style.top = e.clientY+'px';
          contextMenu.style.display = 'block';
        });

        div.addEventListener('mousedown', e=>{
          if (e.button!==0 || e.target.classList.contains('port')) return;
          dragging = {node, offsetX:e.clientX-node.x, offsetY:e.clientY-node.y};
        });

        portOut.addEventListener('mousedown', e=>{
          e.stopPropagation();
          connecting = {source: node.id};
        });

        portIn.addEventListener('mouseup', e=>{
          if (connecting && connecting.source !== node.id) {
            edges = edges.filter(e=>!(e.source===connecting.source && e.target===node.id));
            edges.push({source:connecting.source, target:node.id});
            connecting = null;
            render();
            saveFlow();
          }
        });

        canvas.appendChild(div);
      });
    }

    function render() { renderNodes(); drawConnections(); }

    document.addEventListener('mousemove', e=>{
      if (dragging) {
        dragging.node.x = e.clientX - dragging.offsetX;
        dragging.node.y = e.clientY - dragging.offsetY;
        render();
        saveFlow();
      }
    });

    document.addEventListener('mouseup', ()=>{ dragging=null; connecting=null; });
    document.addEventListener('click', ()=>{ contextMenu.style.display='none'; });

    function deleteNode(id){
      nodes = nodes.filter(n=>n.id!==id);
      edges = edges.filter(e=>e.source!==id && e.target!==id);
      render();
      saveFlow();
    }

    function resetCanvas(){
      if(confirm('Yakin hapus semua node & koneksi?')){
        nodes = []; edges = [];
        localStorage.removeItem('nodes'); localStorage.removeItem('edges');
        render();
      }
    }

    function saveFlow(){ localStorage.setItem('nodes',JSON.stringify(nodes)); localStorage.setItem('edges',JSON.stringify(edges)); }
    function loadFlow(){ location.reload(); }

    function exportFlow(){
      const flow = nodes.map(n=>({
        id:n.id,
        type:n.type==='input'?'inject':n.type==='output'?'debug':n.type==='function'?'function':n.type,
        name:n.label,
        x:n.x, y:n.y,
        wires:edges.filter(e=>e.source===n.id).map(e=>[e.target])
      }));
      const a=document.createElement('a');
      a.href=URL.createObjectURL(new Blob([JSON.stringify(flow,null,2)],{type:'application/json'}));
      a.download='flow-ngemiel.json'; a.click();
    }

    render();
  </script>
</body>
</html>
